{
    "collab_server" : "",
    "contents" : "#' @title Gridworld environment\n#'\n#' @description Simple gridworld for reinforcement learning. Given a state and an action,\n#' the next state and reward are returned.\n#'\n#' @details Possible actions include going left, right, down or up. If an action would take you off\n#' the grid, you remain in the previous state. For each step you get a reward of -1, until you reach\n#' into a terminal state.\n#'\n#' @param state the current state, e.g. c(1, 3)\n#' @param action the action, one of (\"left\", \"right\", \"up\", \"down\")\n#' @param shape the shape of the grid, e.g. (4, 4)\n#' @param terminalStates list of terminal states, each list element is a length two vector\n#' @return list with next state, reward and a flag if episode is finished, i.e. the new state is\n#' a terminal state\n#'\n#' @examples\n#' actions = c(\"left\", \"right\", \"up\", \"down\")\n#' states = matrix(c(3, 3), nrow = 1, ncol = 2)\n#' rewards = numeric(0)\n#' sampledActions = character(0)\n#' episodeOver = FALSE\n#' i = 1\n#'\n#' while(episodeOver == FALSE) {\n#'   sampledActions = append(sampledActions, sample(actions, size = 1))\n#'   i = i + 1\n#'   step = gridworld(states[i - 1, ], sampledActions[i - 1])\n#'   rewards = append(rewards, step[[\"reward\"]])\n#'   states = rbind(states, step[[\"state\"]])\n#'   episodeOver = step[[\"episodeOver\"]]\n#' }\n#'\n#' print(sampledActions)\n#' print(rewards)\n#' print(states)\n#'\n#' @references Gridworld example from Sutton & Barto, chapter 4\ngridworld <- function(state, action, shape = c(4, 4), terminalStates = list(c(1, 1), c(4, 4))) {\n\n  terminalStates = matrix(unlist(terminalStates), ncol = 2, byrow = TRUE)\n  # n_states = prod(shape)\n  # n_actions = 4\n\n  # possible actions:\n  up = c(-1, 0)\n  down = c(1, 0)\n  right = c(0, 1)\n  left = c(0, -1)\n\n  # Flag if episode is over\n  episodeOver = FALSE\n\n  # make action\n  if(action == \"left\"){\n    nextState = state + left\n  } else if(action == \"right\"){\n    nextState = state + right\n  } else if(action == \"up\"){\n    nextState = state + up\n  } else if(action == \"down\"){\n    nextState = state + down\n  }\n\n  # check if new state is inside grid else set new state to old state\n  states_inside_grid = as.matrix(expand.grid(seq(1, shape[1]), seq(1, shape[2])))\n  if(!duplicated(rbind(states_inside_grid, matrix(nextState, ncol = 2)))[-seq_len(nrow(states_inside_grid))]) {\n    nextState = state\n  }\n\n  # episode over if terminalState is reached\n  if(duplicated(rbind(terminalStates, matrix(nextState, ncol = 2)))[-seq_len(nrow(terminalStates))]) {\n    episodeOver = TRUE\n  }\n\n  reward = -1\n\n  return(list(state = nextState, reward = reward, episodeOver = episodeOver))\n}\n",
    "created" : 1486409031896.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2714176191",
    "id" : "F2D69B89",
    "lastKnownWriteTime" : 1486410161,
    "last_content_update" : 1486410161787,
    "path" : "~/GitHub/reinforceR/R/gridworld.R",
    "project_path" : "R/gridworld.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}