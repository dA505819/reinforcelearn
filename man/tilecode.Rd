% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tileCoding.R
\name{tilecode}
\alias{tilecode}
\title{Tile Coding}
\usage{
tilecode(x, y, n.tilings, n.tiles, tilemove.x, tilemove.y, lower.bound.x,
  lower.bound.y, upper.bound.x, upper.bound.y)
}
\arguments{
\item{x}{[\code{numeric(1)}] \cr x: first dimension of the state.}

\item{y}{[\code{numeric(1)}] \cr y: second dimension of the state.}

\item{n.tilings}{[\code{integer(1)}] \cr Number of tilings.}

\item{n.tiles}{[\code{integer(1)}] \cr Number of tiles per tiling.}

\item{tilemove.x}{[\code{numeric(1)}] \cr Tile offset in x direction.}

\item{tilemove.y}{[\code{numeric(1)}] \cr Tile offset in y direction.}

\item{lower.bound.x}{[\code{numeric(1)}] \cr Lower bound of x.}

\item{lower.bound.y}{[\code{numeric(1)}] \cr Lower bound of y.}

\item{upper.bound.x}{[\code{numeric(1)}] \cr Upper bound of x.}

\item{upper.bound.y}{[\code{numeric(1)}] \cr Upper bound of y.}
}
\value{
[\code{vector(n.tilings)}]: the tile indices which are active.
}
\description{
Tile Coding for a two-dimensional state space with uniformly offset tilings.
}
\examples{
tilecode(x = 0.3, y = 0.1, n.tilings = 2, tilemove.x =  - 0.4 / n.tilings, 
  tilemove.y = - 0.4 / n.tilings, lower.bound.x = 0, lower.bound.y = 0, 
  upper.bound.x = 1, upper.bound.y = 1)

\dontrun{
MountainCar = makeEnvironment("MountainCar-v0")
MountainCar$reset()
bounds = MountainCar$state.space.bounds
tilecode(MountainCar$state[[1]], MountainCar$state[[2]], n.tilings = 8, n.tiles = 16, 
  tilemove.x = - 0.2125 / n.tilings, tilemove.y = - 0.0175 / n.tilings, 
  lower.bound.x = bounds[[1]][1], lower.bound.y = bounds[[2]][1], 
  upper.bound.x = bounds[[1]][2], upper.bound.y = bounds[[2]][2])
}
}
\references{
Sutton & Barto (2017): Reinforcement Learning: An Introduction
}
